import random #for dice engine
from sys import exit # to quit the game on death

from DiceEngine import diceEngine #for random rolls by d8 distribution
from Monsters import monster #holds the monster classes and their action functions and equipment/attribute dictionaries
from Monsters import skeleton #specific monster import
from Hero import hero #hero class and its actions, equipment and attributes

#from items import items

from items import armor

attributes = {1: "low4d8",
			2: "low3d8",
			3: "2d8",
			4: "high3d8",
			5: "high4d8",
}

class Scene(object):
	#this is the base scene that all other scenes pull basic properties from. 
	#add in stuff to communicate with hero class here
	def enter(self):
		print "This scene is not yet configured. Subclass it and implement enter()."
		exit(1)


	
#The Engine class runs the game with a while loop
class Engine(object):

    def __init__(self, scene_map):
        #print "Engine has scene_map", scene_map
        self.scene_map = scene_map

    def play(self):
        current_scene = self.scene_map.opening_scene()
        #print "Play's first scene", current_scene
	

        while True:
            print "\n--------\n", toon.print_status()
            next_scene_name = current_scene.enter()
            #print "next scene", next_scene_name
            current_scene = self.scene_map.next_scene(next_scene_name)
            #print "map returns new scene", current_scene
			

	
class Death(Scene):
	
	def enter(self):
		print "Well, you died. That sucks for you, but someone else lived."
		exit(1)


class Meadow(Scene):
	#first entrance

	def enter(self):
		"""Needs two cases, one for the first entrance, another for coming back"""
		entry_string = """\r\rThe meadow is sun dappled and smells of orange blossoms. \nThere is a cave entrance nearby. You can hear a low keening coming from the mouth of the cave"""

	
		print entry_string
		toon.print_status()
		action = 0
		while action <> 1 or action <> 2:
			
			action = raw_input("What do you do? \n--------\n 1. enter cave, 2. equip: ")
				
			if action == "1":
				return 'cave_entrance'
			elif action == "2":
				#print armor.show(scale)
				toon.equip('scale')
			elif action == "stop":
				return 'death'
			#else:
			#	return 'meadow'
			
class CaveEntrance(Scene):
	#need a way to flag if skeleton is gone
	
	def enter(self):
		if skeleton.alive == True:
			entry_string = """As you enter the cave, a skeleton confronts you. It brandishes its sword and gnashes its terrible teeth"""
			print entry_string
			action = 0
			
			while action <> 2 or action <> 2:	
				action = raw_input("Do you approach the skeleton? \n--------\n 1. approach, 2. flee: ")
		
				if action == "1":
					return toon.battle(skeleton)
				elif action == "2":
					print "you ran like a bitch"
					return 'meadow'

		else:
			entry_string = """The shattered bones of a skeleton lie on the cavern floor"""
			print "Do you proceed deeper into the cave?"
			action = raw_input("1. proceed, 2. flee  :")
			if action == '1':
				print "You are so intrepid"
				exit(1)
			elif action == '2':
				return 'meadow'
			else:
				print "you need to lock user inputs better"
				return 'meadow'
		
			
#The map class contains a list of all the scenes in the game
#Scenes are held in a dictionary that passes them to functions based on return values in other classes

class Map(object):
	
	scenes = {
		'meadow': Meadow(), 
		'cave_entrance': CaveEntrance(), 
		'death': Death(),
		
	}
		
	def __init__(self, start_scene):
		self.start_scene = start_scene
		
	def next_scene(self, scene_name):
		return Map.scenes.get(scene_name)
		
	def opening_scene(self):
		return self.next_scene(self.start_scene)		

cave_entrance_visited = False
armor = armor()

skeleton = skeleton()
#syntax or reading the keys and values from a dictionary
#for key, value in armor.scale:
#	print key, value
#	#print armor.scale.get(key)

#stuff = 'name'
#print armor.scale[stuff]	
toon = hero()

#print "armor type is: ", toon.scale.get('name')

dice = diceEngine()	
a_map = Map('meadow')
a_game = Engine(a_map)
a_game.play()

